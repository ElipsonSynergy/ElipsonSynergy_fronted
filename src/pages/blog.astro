---
import BaseLayout from '../layouts/BaseLayout.astro';
import { useTranslations } from '../utils/i18n';
import BlogsListBanner from "../components/BlogsListBanner.astro";
import BlogCard from "../components/BlogCard.astro";

export async function getStaticPaths() {
  return [
    { params: { locate: 'es' } },
    { params: { locate: 'en' } },
    { params: { locate: 'por' } }
  ];
}

const { locate } = Astro.params;
const lang = (locate as 'es' | 'en' | 'por') || 'es';
const t = useTranslations(lang);

/**
 * Tag interface matching TagDto from backend
 * Represents a blog post tag with unique identifier and name
 *
 * @interface TagType
 * @property {string} id - Unique identifier for the tag
 * @property {string} name - Display name of the tag
 */
interface TagType {
    id: string;
    name: string;
}

/**
 * Author interface matching AuthorDto from backend
 * Represents blog post author information with optional profile data
 *
 * @interface AuthorType
 * @property {string} id - Unique identifier for the author
 * @property {string} name - Full name of the author
 * @property {string} [bio] - Optional author biography (can be null or undefined)
 * @property {string} [avatarUrl] - Optional author avatar image URL (can be null or undefined)
 */
interface AuthorType {
    id: string;
    name: string;
    bio?: string; // can be null or undefined
    avatarUrl?: string; // can be null or undefined
}

/**
 * Post interface matching PostDto from backend
 * Represents a complete blog post with all associated data
 *
 * @interface PostType
 * @property {string} id - Unique identifier for the post
 * @property {string} slug - URL-friendly slug for SEO
 * @property {string} title - Post title
 * @property {string} summary - Brief post summary/excerpt
 * @property {string} content - Full post content
 * @property {string|null} imageUrl - Featured image URL (can be null)
 * @property {string} createdAt - ISO date string of creation
 * @property {string} updatedAt - ISO date string of last update
 * @property {AuthorType} author - Post author information
 * @property {TagType[]} tags - Array of associated tags
 */
interface PostType {
    id: string;
    slug: string;
    title: string;
    summary: string;
    content: string;
    imageUrl: string | null;
    createdAt: string;
    updatedAt: string;
    author: AuthorType;
    tags: TagType[];
}

/**
 * API endpoint for posts data
 * @constant {string}
 */
const POSTS_API = "http://localhost:3000/api/posts";

/**
 * API endpoint for tags data
 * @constant {string}
 */
const TAGS_API = "http://localhost:3000/api/tags";

// Extract and process URL parameters for search, filtering, and pagination
const url = new URL(Astro.request.url);
const search = url.searchParams.get("search")?.toLowerCase() || "";
const tag = url.searchParams.get("tag") || "All";
const pageNum = parseInt(url.searchParams.get("page") || "1", 10);

/**
 * Number of posts to display per page
 * @constant {number}
 */
const pageSize = 9;

/**
 * Fetch blog posts from API with error handling
 * @throws {Error} When API request fails
 */
const postsRes = await fetch(POSTS_API);
if (!postsRes.ok) throw new Error(`Error loading posts: ${postsRes.status}`);
const posts: PostType[] = await postsRes.json();

/**
 * Fetch available tags from API with graceful fallback
 * Falls back to empty array if tags API fails
 */
const tagsRes = await fetch(TAGS_API);
const tagsData: TagType[] = tagsRes.ok ? await tagsRes.json() : [];

/**
 * Build complete list of tag names for filter selector
 * Includes "All" option for showing all posts
 * @constant {string[]}
 */
const allTags: string[] = ["All", ...tagsData.map((t) => t.name.toUpperCase())];

/**
 * Filter posts based on search query and selected tag
 * Search is performed across post titles and summaries (case-insensitive)
 * Tag filtering supports "All" option and exact tag name matching
 */
const filtered = posts.filter(
    (p) =>
        (p.title.toLowerCase().includes(search) ||
            p.summary.toLowerCase().includes(search)) &&
        (tag === "All" || p.tags.some((t) => t.name.toUpperCase() === tag)),
);

/**
 * Calculate pagination values
 */
const total = filtered.length;
const totalPages = Math.ceil(total / pageSize);
const start = (pageNum - 1) * pageSize;

/**
 * Get current page slice of filtered posts
 * @constant {PostType[]}
 */
const slice: PostType[] = filtered.slice(start, start + pageSize);
---

<BaseLayout>
    <!-- Page header with banner image and title -->
        <BlogsListBanner title="Blog Squair" image="/banner.jpg" />

        <!-- 
          Search and Filter Section
          
          Provides user interface for searching blog posts and filtering by tags.
          Uses server-side rendering for initial state and client-side JavaScript for interactions.
        -->
        <section class="search-filter">
            <!-- Left column: Search title and form -->
            <div class="left-column">
                <!-- Section heading -->
                <h2>Descubre más sobre lo que es importante para ti</h2>

                <!-- 
                  Search Form
                  
                  Allows users to search through blog post titles and content.
                  Preserves current tag filter when performing search.
                  Uses GET method for SEO-friendly URLs.
                -->
                <form method="get" class="search-form">
                    <input
                        type="text"
                        name="search"
                        placeholder="Buscar"
                        value={search}
                        aria-label="Buscar en el blog"
                    />
                    <button type="submit" aria-label="Buscar">
                        <!-- Search icon SVG -->
                        <svg
                            width="16"
                            height="16"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                            stroke-width="2"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                        >
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.35-4.35"></path>
                        </svg>
                    </button>
                </form>
            </div>

            <!-- 
              Tag Filter Navigation
              
              Displays clickable tag buttons for filtering blog posts by category.
              Includes "All" option to show posts from all categories.
              Preserves search term when changing tag filters.
            -->
            <div
                class="tags"
                role="navigation"
                aria-label="Filtros de categoría"
            >
                {
                    allTags.map((t) => (
                        <a
                            class={t === tag ? "tag active" : "tag"}
                            href={`?tag=${encodeURIComponent(t)}&search=${encodeURIComponent(search)}`}
                        >
                            {t}
                        </a>
                    ))
                }
            </div>
        </section>

        <!-- Blog posts grid layout -->
        <section class="posts-grid">
            <!-- Blocque de “no results” siempre presente, oculto inicialmente -->
            <div class="no-results" style="display: none;">
                <h3>No se encontraron resultados</h3>
                <p>Intenta ajustar tu búsqueda o los filtros</p>
            </div>

            <!-- Aquí van todas las cards, sin condicionar -->
            {slice.map((post) => <BlogCard post={post} />)}
        </section>

        <!-- 
          Pagination Navigation
          
          Provides navigation controls for browsing through multiple pages of blog posts.
          Only rendered when there are posts to display.
          Includes previous/next arrows and numbered page links.
          Preserves search and tag filter state across page navigation.
        -->
        {
            totalPages > 0 && (
                <nav
                    class="pagination"
                    role="navigation"
                    aria-label="Navegación de páginas"
                >
                    {/* 
                      Previous Arrow
                      
                      Navigation to previous page, only shown when:
                      - There are multiple pages (totalPages > 1)
                      - Current page is not the first page (pageNum > 1)
                    */}
                    {totalPages > 1 && pageNum > 1 && (
                        <a
                            class="page arrow"
                            href={`?page=${pageNum - 1}&tag=${encodeURIComponent(tag)}&search=${encodeURIComponent(search)}`}
                            aria-label="Página anterior"
                        >
                            ‹
                        </a>
                    )}

                    {/* 
                      Page Number Links
                      
                      Generates numbered links for each page.
                      Current page is highlighted with 'active' class.
                      Each link preserves current search and tag filter state.
                    */}
                    {Array.from({ length: totalPages }, (_, i) => (
                        <a
                            class={i + 1 === pageNum ? "page active" : "page"}
                            href={`?page=${i + 1}&tag=${encodeURIComponent(tag)}&search=${encodeURIComponent(search)}`}
                            aria-label={
                                i + 1 === pageNum
                                    ? `Página actual: ${i + 1}`
                                    : `Ir a página ${i + 1}`
                            }
                        >
                            {i + 1}
                        </a>
                    ))}

                    {/* 
                      Next Arrow
                      
                      Navigation to next page, only shown when:
                      - There are multiple pages (totalPages > 1)
                      - Current page is not the last page (pageNum < totalPages)
                    */}
                    {totalPages > 1 && pageNum < totalPages && (
                        <a
                            class="page arrow"
                            href={`?page=${pageNum + 1}&tag=${encodeURIComponent(tag)}&search=${encodeURIComponent(search)}`}
                            aria-label="Página siguiente"
                        >
                            ›
                        </a>
                    )}
                </nav>
            )
        }
        <!-- 
          Client-Side Interactive Functionality
          
          This script provides enhanced user experience through client-side filtering and search.
          Works alongside server-side rendering to provide immediate feedback without page reloads.
          
          Key Features:
          - Real-time search as user types
          - Multi-tag filtering with visual feedback
          - Instant post visibility updates
          - "No results" message management
          - Preserves accessibility features
        -->
        <script type="module">
            /** @type {HTMLAnchorElement[]} */
            const tagButtons = Array.from(
                document.querySelectorAll(".tags .tag"),
            );
            /** @type {HTMLElement[]} */
            const postCards = Array.from(
                document.querySelectorAll(".card.post-card"),
            );
            /** @type {HTMLFormElement | null} */
            const form = document.querySelector(".search-form");
            /** @type {HTMLInputElement | null} */
            const searchInput =
                form?.querySelector('input[name="search"]') ?? null;
            /** @type {HTMLElement | null} */
            const noResultsEl = document.querySelector(
                ".posts-grid .no-results",
            );

            /** @type {string[]} */
            let selectedTags = [];
            /** @type {string} */
            let searchTerm = searchInput?.value.trim().toLowerCase() || "";

            // Maneja el submit: evita recarga, toma el valor y filtra
            form?.addEventListener("submit", (e) => {
                e.preventDefault();
                searchTerm = searchInput.value.trim().toLowerCase();
                filterPosts();
            });

            function updateUI() {
                tagButtons.forEach((btn) => {
                    const name = btn.textContent?.trim().toUpperCase() || "";
                    btn.classList.toggle(
                        "active",
                        name === "ALL"
                            ? selectedTags.length === 0
                            : selectedTags.includes(name),
                    );
                });
            }

            function filterPosts() {
                let anyVisible = false;

                postCards.forEach((card) => {
                    // tags
                    const tagsAttr = card.getAttribute("data-tags") || "";
                    const cardTags = tagsAttr
                        .split(",")
                        .map((t) => t.trim().toUpperCase());
                    const matchesTag =
                        selectedTags.length === 0 ||
                        selectedTags.some((tag) => cardTags.includes(tag));

                    // búsqueda
                    const hayTagsTxt = tagsAttr
                        .toLowerCase()
                        .includes(searchTerm);
                    const title = card.getAttribute("data-title") || "";
                    const summary = card.getAttribute("data-summary") || "";
                    const content = card.getAttribute("data-content") || "";
                    const author = card.getAttribute("data-author") || "";
                    const slug = card.getAttribute("data-slug") || "";
                    const hayTexto = [
                        title,
                        summary,
                        content,
                        author,
                        slug,
                        hayTagsTxt ? tagsAttr.toLowerCase() : "",
                    ].some((field) => field.includes(searchTerm));

                    const visible =
                        matchesTag && (searchTerm === "" || hayTexto);
                    card.style.display = visible ? "" : "none";
                    if (visible) anyVisible = true;
                });

                // muestra/oculta “no results”
                if (noResultsEl) {
                    noResultsEl.style.display = anyVisible ? "none" : "";
                }
            }

            tagButtons.forEach((btn) => {
                btn.addEventListener("click", (e) => {
                    e.preventDefault();
                    const name = btn.textContent?.trim().toUpperCase() || "";
                    if (name === "ALL") {
                        selectedTags = [];
                    } else {
                        const idx = selectedTags.indexOf(name);
                        if (idx >= 0) selectedTags.splice(idx, 1);
                        else selectedTags.push(name);
                    }
                    updateUI();
                    filterPosts();
                });
            });

            // Initialize application with proper documentation
            updateUI();
            filterPosts();
        </script>
</BaseLayout>