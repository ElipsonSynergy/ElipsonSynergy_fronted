---
export const prerender = false;

import { Image } from "astro:assets";
import BaseLayout from '../../../layouts/BaseLayout.astro';
import { useTranslations, languages, getLangFromUrl } from '../../../utils/i18n';
// Firestore (un solo entrypoint)
import {
  db, collection, getDocs, getDoc, query, where, orderBy, limit, doc
} from '../../../lib/firebase';


// ===== i18n =====
export async function getStaticPaths() {
  return Object.keys(languages).map((loc) => ({
    params: { locate: loc },
  }));
}
const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

// ===== Tipos =====
interface AuthorType {
  id?: string;
  name?: string;
  bio?: string;
  avatarUrl?: string;
}
interface PostType {
  id: string;
  slug: string;
  title: string;
  summary?: string;
  content?: any;              // string (MD/HTML) o JSON simple
  imageUrl?: string | null;
  createdAt?: string;
  updatedAt?: string;
  author?: AuthorType;
  tags?: string[];
  locale?: string;
  published?: boolean;
}

// ===== Caché en memoria (por instancia del server) =====
type DetailEntry = { expires: number; data: PostType };
type ListEntry = { expires: number; data: PostType[] };
const TTL = 5 * 60 * 1000; // 5 minutos

const g: any = globalThis as any;
g.__DETAIL_CACHE ??= new Map<string, DetailEntry>();
g.__RELATED_CACHE ??= new Map<string, ListEntry>();
const DETAIL_CACHE: Map<string, DetailEntry> = g.__DETAIL_CACHE;
const RELATED_CACHE: Map<string, ListEntry> = g.__RELATED_CACHE;

function getDetailCache(key: string): PostType | null {
  const hit = DETAIL_CACHE.get(key);
  if (!hit) return null;
  if (Date.now() > hit.expires) {
    DETAIL_CACHE.delete(key);
    return null;
  }
  return hit.data;
}
function setDetailCache(key: string, data: PostType) {
  DETAIL_CACHE.set(key, { expires: Date.now() + TTL, data });
}
function getRelatedCache(key: string): PostType[] | null {
  const hit = RELATED_CACHE.get(key);
  if (!hit) return null;
  if (Date.now() > hit.expires) {
    RELATED_CACHE.delete(key);
    return null;
  }
  return hit.data;
}
function setRelatedCache(key: string, data: PostType[]) {
  RELATED_CACHE.set(key, { expires: Date.now() + TTL, data });
}

// ===== Helpers =====
function toIso(v: any): string | undefined {
  if (!v) return undefined;
  if (v?.toDate) return v.toDate().toISOString();
  if (typeof v === 'string') return v;
  return new Date().toISOString();
}

// Mapea un doc de Firestore a PostType
function mapDoc(id: string, d: any): PostType {
  return {
    id,
    slug: d.slug ?? id,
    title: d.title ?? '',
    summary: d.summary ?? '',
    content: d.content,
    imageUrl: d.imageUrl ?? null,
    createdAt: toIso(d.createdAt),
    updatedAt: toIso(d.updatedAt ?? d.createdAt),
    author: d.author ?? {},
    tags: Array.isArray(d.tags) ? d.tags.map((x: any) => String(x)) : [],
    locale: d.locale,
    published: d.published,
  };
}

async function findBySlug(slug: string): Promise<PostType | null> {
  const qy = query(
    collection(db, 'blogs'),
    where('slug', '==', slug),
    limit(1)
  );
  const snap = await getDocs(qy);
  if (snap.empty) return null;
  const s = snap.docs[0];
  return mapDoc(s.id, s.data());
}

async function findById(id: string): Promise<PostType | null> {
  const ref = doc(db, 'blogs', id);
  const s = await getDoc(ref);
  if (!s.exists()) return null;
  return mapDoc(s.id, s.data());
}

// ===== Parámetro dinámico =====
const detail = (Astro.params as Record<string, string>).detail!;

// Normaliza lo que viene en la URL
const detailParam = decodeURIComponent(detail).trim();

// ===== Resuelve desde caché o Firestore =====
const cacheKey = `detail:${detail}`;
let blog: PostType | null = getDetailCache(cacheKey);

if (!blog) {
  // Probamos ambas búsquedas en paralelo
  const [bySlug, byId] = await Promise.all([
    findBySlug(detailParam),
    findById(detailParam),
  ]);
  blog = bySlug ?? byId ?? null;

  if (blog) setDetailCache(cacheKey, blog);

  // logging de ayuda (aparece en consola del server)
  console.log('[detail] param =', detailParam, 'foundBy', bySlug ? 'slug' : byId ? 'id' : 'none');
}

// ===== Cabecera HTTP para cache del HTML =====
Astro.response.headers.set('Cache-Control', 'public, max-age=60, stale-while-revalidate=300');

// ===== Contenido HTML =====
// Si content es string, lo usamos tal cual; si viene un JSON sencillo tipo [{type:"paragraph", children:[{text:"..."}]}],
// lo convertimos a <p>...</p> de forma básica para no depender de reactJsonToHtmlString.
function richToHtml(content: any): string {
  if (!content) return '';

  // pequeño helper para no inyectar HTML accidental
  const esc = (s: string) =>
    s.replace(/&/g, '&amp;')
     .replace(/</g, '&lt;')
     .replace(/>/g, '&gt;');

  if (typeof content === 'string') {
    // normaliza saltos de línea: "\n" -> real
    let s = content.includes('\\n') ? content.replace(/\\n/g, '\n') : content;
    s = s.replace(/\r\n?/g, '\n');

    const lines = s.split('\n');
    const out: string[] = [];
    let para: string[] = [];

    const flushPara = () => {
      if (!para.length) return;
      // más espacio entre párrafos + mejor legibilidad
      out.push(`<p class="mb-6 leading-relaxed">${esc(para.join(' '))}</p>`);
      para = [];
    };

    for (const raw of lines) {
      const line = raw.trimEnd();

      // línea en blanco => cierra párrafo
      if (!line.trim()) {
        flushPara();
        continue;
      }

      // encabezados Markdown básicos
      let m: RegExpMatchArray | null;
      if ((m = line.match(/^###\s+(.*)$/))) {
        flushPara();
        out.push(`<h3 class="mt-8 mb-3 font-semibold text-xl">${esc(m[1])}</h3>`);
        continue;
      }
      if ((m = line.match(/^##\s+(.*)$/))) {
        flushPara();
        out.push(`<h2 class="mt-10 mb-4 font-bold text-2xl">${esc(m[1])}</h2>`);
        continue;
      }
      if ((m = line.match(/^#\s+(.*)$/))) {
        flushPara();
        out.push(`<h1 class="mt-12 mb-4 font-bold text-3xl">${esc(m[1])}</h1>`);
        continue;
      }

      // línea "normal" => acumula para párrafo
      para.push(line);
    }

    flushPara();
    return out.join('');
  }

  // Fallback para array tipo [{type:'paragraph', children:[{text:'...'}]}]
  try {
    if (Array.isArray(content)) {
      return content
        .map((n) =>
          n?.type === 'paragraph' && Array.isArray(n.children)
            ? `<p class="mb-6 leading-relaxed">${n.children.map((c: any) => esc(c?.text ?? '')).join('')}</p>`
            : ''
        )
        .join('');
    }
    return String(content);
  } catch {
    return '';
  }
}

const htmlContent = richToHtml(blog?.content);

// ===== Relacionados (recientes) con caché =====
async function getRecent(limitCount = 5): Promise<PostType[]> {
  const key = `recent:${lang}:${limitCount}`;
  const hit = getRelatedCache(key);
  if (hit) return hit;

  const qy = query(
    collection(db, 'blogs'),
    where('published', '==', true),
    orderBy('createdAt', 'desc'),
    limit(limitCount + 5) // por si filtramos el actual
  );
  const snap = await getDocs(qy);
  const items = snap.docs.map((d) => mapDoc(d.id, d.data()));
  setRelatedCache(key, items);
  return items;
}

const relatedRaw = await getRecent(5);
const related = blog ? relatedRaw.filter((p) => p.id !== blog.id).slice(0, 5) : relatedRaw.slice(0, 5);

// Para construir URLs localizadas simples:
const base = lang === 'es' ? '/es' : `/${lang}`;
---
<BaseLayout title={blog?.title || "Blog"}>
  {blog ? (
    <section class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8 py-20">
        {blog.imageUrl ? (
            <Image
                src={blog.imageUrl}
                alt={blog.title}
                class="card-image"
                width={400}
                height={220}
            />
            ) : (
            <Image
                src="/banner.jpg"  
                alt={blog.title}
                class="card-image"
                width={400}
                height={220}
            />
            )}


      <div class="grid grid-cols-1 lg:grid-cols-3 gap-12">
        <!-- Contenido principal -->
        <div class="col-span-2 space-y-10">
          <div class="text-center">
            <h1 class="text-4xl font-bold text-gray-900">{blog.title}</h1>
            {blog.summary && <p class="text-lg text-gray-500">{blog.summary}</p>}
          </div>



          <div class="prose max-w-none prose-lg" set:html={htmlContent}></div>

          {blog.tags?.length && (
            <div class="flex flex-wrap gap-2 mt-6">
              {blog.tags.map((label: string) => (
                <span class="inline-block bg-gray-200 text-gray-700 px-3 py-1 rounded-full text-sm">#{label}</span>
              ))}
            </div>
          )}

          <div class="text-sm text-gray-500">
            {blog.createdAt && <>Publicado el: {new Date(blog.createdAt).toLocaleDateString()}</>}
          </div>

          {blog.author?.name && (
            <div class="border-t pt-6 mt-6">
              <p class="text-gray-600">Autor: {blog.author.name}</p>
            </div>
          )}
        </div>

        <!-- Sidebar -->
        <aside class="col-span-1">
          <div class="bg-gray-100 p-6 rounded-lg">
            <h2 class="text-xl font-bold mb-4">Artículos Populares</h2>
            <div class="space-y-4">
              {related.map((p) => (
                <a href={`${base}/blog/${p.slug ?? p.id}`} class="block bg-white rounded-lg p-4 shadow hover:shadow-md transition">
                  <div class="font-semibold">{p.title}</div>
                  {p.summary && <div class="text-sm text-gray-500 mt-1 line-clamp-2">{p.summary}</div>}
                </a>
              ))}
            </div>
          </div>
        </aside>
      </div>
    </section>
  ) : (
    <div class="text-center py-20 text-red-600 font-semibold text-xl">
      Blog no encontrado.
    </div>
  )}
</BaseLayout>
